with open('entrada.txt', 'r') as f:
    linhas = [linha.strip() for linha in f if linha.strip()]


numero_de_voos = int(linhas[0])
numero_de_pistas = int(linhas[1])


r = list(map(int, linhas[2].split()))
c = list(map(int, linhas[3].split()))
p = list(map(int, linhas[4].split()))

# matriz t
t = []
for i in range(5, 5 + numero_de_voos):
    t.append(list(map(int, linhas[i].split())))


# Representa√ß√£o de um voo
class Voo:
    def __init__(self, id_voo, r, c, p):
        self.id = id_voo
        self.r = r  # hor√°rio de chegada
        self.c = c  # hor√°rio mais cedo de pouso
        self.p = p  # penalidade por minuto de espera
        self.horario_atribuido = None  # ser√° preenchido na solu√ß√£o
        self.pista_atribuida = None    # idem

# Representa√ß√£o de uma pista
class Pista:
    def __init__(self, id_pista):
        self.id = id_pista
        self.ocupada_em = set()  # hor√°rios em que essa pista j√° est√° ocupada

# Fun√ß√£o que inicializa as estruturas
def inicializar_instancia(numero_de_voos, numero_de_pistas, r, c, p, t):
    voos = [Voo(i, r[i], c[i], p[i]) for i in range(numero_de_voos)]
    pistas = [Pista(i) for i in range(numero_de_pistas)]
    matriz_tempo = t  # matriz t[i][j] = tempo de separa√ß√£o entre voo i e j na mesma pista
    return voos, pistas, matriz_tempo


def printar_instancia(voos, pistas, matriz_tempo):
    print("üì¶ VOOS:")
    for voo in voos:
        print(
            f"Voo {voo.id}: r = {voo.r}, c = {voo.c}, p = {voo.p}, "
            f"hor√°rio atribu√≠do = {voo.horario_atribuido}, pista = {voo.pista_atribuida}"
        )

    print("\nüõ¨ PISTAS:")
    for pista in pistas:
        print(f"Pista {pista.id}, hor√°rios ocupados: {sorted(pista.ocupada_em)}")

    print("\n‚è± MATRIZ DE SEPARA√á√ÉO (t):")
    for i, linha in enumerate(matriz_tempo):
        print(f"Voo {i}: {linha}")


def heuristica_gulosa(voos, pistas, matriz_tempo):
    custo_total = 0

    # Ordena os voos pelo tempo de libera√ß√£o
    voos_ordenados = sorted(voos, key=lambda v: v.r)

    for voo in voos_ordenados:
        melhor_inicio = float('inf')
        melhor_pista = None

        for pista in pistas:
            # Tenta alocar o voo no tempo mais cedo poss√≠vel respeitando separa√ß√£o
            tempo_minimo = voo.r

            for outro_voo in voos:
                if outro_voo.pista_atribuida == pista.id and outro_voo.horario_atribuido is not None:
                    tempo_final = outro_voo.horario_atribuido + outro_voo.c
                    separacao = matriz_tempo[outro_voo.id][voo.id]
                    tempo_minimo = max(tempo_minimo, tempo_final + separacao)

            # Verifica se essa pista √© melhor que a anterior
            if tempo_minimo < melhor_inicio:
                melhor_inicio = tempo_minimo
                melhor_pista = pista

        # Atribui voo √† pista escolhida
        voo.horario_atribuido = melhor_inicio
        voo.pista_atribuida = melhor_pista.id

        # Marca os hor√°rios ocupados
        for t in range(voo.horario_atribuido, voo.horario_atribuido + voo.c):
            melhor_pista.ocupada_em.add(t)

        # Calcula custo de penalidade
        atraso = max(0, voo.horario_atribuido - voo.r)
        penalidade = atraso * voo.p
        custo_total += penalidade

    print(f"\nüí∏ Custo total de penalidade: {custo_total}")







voos, pistas, matriz_tempo = inicializar_instancia(numero_de_voos, numero_de_pistas, r, c, p, t)
heuristica_gulosa(voos, pistas, matriz_tempo)
printar_instancia(voos, pistas, matriz_tempo)

